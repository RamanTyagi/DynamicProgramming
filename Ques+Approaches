
"Those who cannot remember the past are condemned to repeat it!!!!!!"

{ Recursion : Try all ways / figure out ways / Best ways , Find max or min in something!! }
1. Try to represent the problem in terms of index.
2. Do all the possible stuffs on that index acc. to the problem statement.
3. Sum up all stuffs { count all ways }
4. min/max of all stuffs { find min/max }

DYNAMIC PROGRAMMING : 

->Dynamic Programming can be described as storing answers to various sub-problems to be used later whenever required to solve the main problem.

*The two common dynamic programming approaches are:

->Memoization: Known as the “top-down” dynamic programming, usually the problem is solved in the direction of the main problem to the base cases.
   * We tend to store the values of sub problems in some map/table }
   * Jitne parameters change ho rhe honge us hisab se DP bnegi ex: agr 2 parameter change ho rhe h to 2D Dp , 3 kr rhe hai to 3D Dp.

->Tabulation: Known as the “bottom-up ” dynamic programming, usually the problem is solved in the direction of solving the base cases to the main problem.
  * Stack space ko htane ke liye tabulation use krte hai!
  
*Sbse phle recursive solution socho top-down , Agr overlapping subproblems hai to :
*dp lga do optimise krne ke lie.
*Recursive -> memoization { Use dp with inital values as -1 } [ Pick/not_pick concept or by looping around indexes!!! ] 
*memoization -> tabulation { Phle bases cases bnao fir memoization wala code copy krdo loop lga kr }


1. 1D DP:

2. 2D DP:

3. LCS Pattern Based:

4. LIS Pattern Based:
   1. https://leetcode.com/problems/longest-string-chain/ { top down approach mein index use kro rather than string --> Jisse memoization easy ho jae!!!!}
5. Stocks problems:

6. DP on Squares :


7. DP on trees :
 * Identification:
  -> If there is case of traversing the tree for two times , one for finding what we are looking for and other one we require for finding current one.
  -> For ex : For finding diameter of binary tree , we have to also find height . 
  -> In such cases Tc: O(n2)
  -> To optimise such cases we apply dynamic programming on trees.
 * General Syntax :
  -> int solve(Node *root,int& res)
    {
        if(root==NULL)
          return 0;
        int l = solve(root->left,res);
        int r = solve(root->right,res);
        int temp = Calculate temp ans; // 1+max(l,r)
        int ans = max(temp,relation); // relation : 1+l+r
        res = max(res,ans);
        return temp;
    }
  * Problems:
  1. Diameter of a Binary Tree - LINK: https://leetcode.com/problems/diameter-of-binary-tree/
  2. Binary Tree Maximum Path Sum - LINK: https://leetcode.com/problems/binary-tree-maximum-path-sum/








